%-------------------------------------------------------------------------------
% seq24_rc_file
%-------------------------------------------------------------------------------
%
% \file        seq24_rc_file.tex
% \library     Documents
% \author      Chris Ahlstrom
% \date        2015-07-20
% \update      2016-05-20
% \version     $Revision$
% \license     $XPC_GPL_LICENSE$
%
%     Provides the rc_file.
%
%-------------------------------------------------------------------------------

\section{Seq24rc Configuration File}
\label{sec:seq24_rc_file}

   \index{.seq24rc}
   \index{[.seq24rc]}   % for convenience
   The \textsl{Seq24} configuration file is called
   \texttt{.seq24rc}, and it is stored in the user's \texttt{\$HOME}
   directory.

   After you run \textsl{Seq24} for the first time, it will generate a
   \texttt{.seq24rc} file in your home directory.
   It contains the the data for remote MIDI control, keyboard
   control, and MIDI clock.

   \textsl{Seq24} will overwrite the \texttt{.seq24rc} file on quit.  One
   should therefore quit \textsl{Seq24} before doing manual modifications
   to the \texttt{.seq24rc} file.

\subsection{Seq24rc / MIDI Control Section}
\label{subsec:seq24_rc_file_midi_control}

   \textsl{Seq24} provides a way to control the
   application to some extent via a MIDI controller, such as a MIDI keyboard or
   a MIDI pad device.  The current section describes this feature;
   additional resources can be found a \url{linuxaudio.org}

   \index{[midi-control]}
   For each pattern, we can set up MIDI events to turn a 
	pattern on, off, or to toggle it.  This setup is in the 
   MIDI Control section of \texttt{.seq24rc}, and begins with an
   "INI" group marker \texttt{[midi-control]}.

   The MIDI control setup resembles a matrix.
   The matrix represents the first two screen-sets
   (entries are numbered from 0
   to 63) and some control keys (entries from 64 to 73).  The three fields,
   each between the brackets, on each line, correspond to a MIDI filter... if
   the incoming MIDI event matches the filter it will \textsl{toggle} (first
   field), \textsl{enable} (second field) or \textsl{disable} (third field) the
   sequence.
	
   THe MIDI Control section is implicitly broken into subsections, though those
   subsections are marked with comment-lines for better comprehensibility.
   The subsections of the MIDI Control section are:

   \begin{enumber}
      \item \textbf{pattern group}.  Consists of 32 lines, one for each
         pattern box shown in the Pattern window.
      \item \textbf{mute in group}.  Consists of 32 lines, one for each
         pattern box shown in the Pattern window.
      \item \textbf{automation group}.  Each item in this group consists of
         one line.
         \begin{enumber}
            \item \textbf{bpm up}. Consists of one line.
            \item \textbf{bpm down}. Consists of one line.
            \item \textbf{screen-set up}. Consists of one line.
            \item \textbf{screen-set down}. Consists of one line.
            \item \textbf{mod replace}. Consists of one line.
            \item \textbf{mod snapshot}. Consists of one line.
            \item \textbf{mod queue}. Consists of one line.
            \item \textbf{mod gmute}. Consists of one line.
            \item \textbf{mod glearn}. Consists of one line.
            \item \textbf{screen-set play}. Consists of one line.
         \end{enumber}
   \end{enumber}

   We see the following lines in the MIDI Control section, which is broken
   into groups or subsections marked by comments:

   \begin{verbatim}
      [midi-control]
      74

      # pattern group
       0  [0 0 0 0 0 0]   [0 0 0 0 0 0]   [0 0 0 0 0 0]            
       1  [0 0 0 0 0 0]   [0 0 0 0 0 0]   [0 0 0 0 0 0]          
       2  [0 0 0 0 0 0]   [0 0 0 0 0 0]   [0 0 0 0 0 0]   
      ...     ...            ...              ...
      31  [0 0 0 0 0 0]   [0 0 0 0 0 0]   [0 0 0 0 0 0]    

      # mute in group
      32  [0 0 0 0 0 0]   [0 0 0 0 0 0]   [0 0 0 0 0 0]   
      33  [0 0 0 0 0 0]   [0 0 0 0 0 0]   [0 0 0 0 0 0]   
      ...     ...            ...              ...
      63  [0 0 0 0 0 0]   [0 0 0 0 0 0]   [0 0 0 0 0 0]   

      # bpm up
      64  [0 0 0 0 0 0]   [0 0 0 0 0 0]   [0 0 0 0 0 0]   

      # bpm down
      65  [0 0 0 0 0 0]   [0 0 0 0 0 0]   [0 0 0 0 0 0]   

      # screen set up
      66  [0 0 0 0 0 0]   [0 0 0 0 0 0]   [0 0 0 0 0 0]   

      # screen set down
      67  [0 0 0 0 0 0]   [0 0 0 0 0 0]   [0 0 0 0 0 0]   

      # mod replace
      68  [0 0 0 0 0 0]   [0 0 0 0 0 0]   [0 0 0 0 0 0]   

      # mod snapshot
      69  [0 0 0 0 0 0]   [0 0 0 0 0 0]   [0 0 0 0 0 0]   

      # mod queue
      70  [0 0 0 0 0 0]   [0 0 0 0 0 0]   [0 0 0 0 0 0]   

      # mod gmute
      71  [0 0 0 0 0 0]   [0 0 0 0 0 0]   [0 0 0 0 0 0]   

      # mod glearn
      72  [0 0 0 0 0 0]   [0 0 0 0 0 0]   [0 0 0 0 0 0]   

      # screen set play
      73  [0 0 0 0 0 0]   [0 0 0 0 0 0]   [0 0 0 0 0 0]   
   \end{verbatim}

   The number (74) is the number of lines in the MIDI Control section.

   The first number is the pattern/sequence number in the main window, which
   ranges from 0 to 31.  Each set of brackets corresponds to a MIDI filter.
   The MIDI filter in the leftmost brackets is the \textsl{toggle} filter.
   The MIDI filter in the middles brackets is the \textsl{on} filter.
   The MIDI filter in the rightmost brackets is the \textsl{off} filter.
   If the incoming MIDI event matches the filter, it will either [toggle],
   [on], or [off] the pattern/sequence, respectively.

   The layout of each filter inside the bracket is as follows:

      [OPR INV STAT D1 D2min D2max]

   where

   \begin{itemize}
      \item \textbf{OPR} = \textbf{on/off}
      \item \textbf{INV} = \textbf{inverse}
      \item \textbf{STAT} = \textbf{MIDI status byte} (channel ignored) 
      \item \textbf{D1} = \textbf{data1}
      \item \textbf{D2min} = \textbf{data2 min}
      \item \textbf{D2max} = \textbf{data2 max}
   \end{itemize}

   If \textbf{on/off} is set to 1, it will match the incoming MIDI against
   the \textbf{MIDI status byte} pattern and perform the action
   (on/off/toggle) if the data falls in the range specified.  All values are
   in decimal.

	The \textbf{inverse} field will make the pattern perform the opposite 
   action (\textsl{off} for \textsl{on}, \textsl{on} for \textsl{off}) if
   the data falls outside the specified range.  This is cool because one can
   map several sequences to a knob or fader.

   The \textbf{MIDI status byte} field a MIDI status byte number in decimals.
   The channel nybble of this byte is ignored.
   One can look the possible status values up in the MIDI messages tables; the
   relevant data can be found in many places on the Web.
   As the channel on which the events are sent is ignored, one should
   always use the values for channel 1.  That is, 0.

	The last three fields describe the range of data that will match.
   The \textbf{data1} field provides the actual MIDI event message number to
   detect, in decimal.
   This item could be a Note On/Off event or a Control/Mode change event,
   for example.

   The \textbf{data2 min} field is the minimum value of the event
   for the filter to match. For Note On/Off events,
   this would be the velocity value, for example.

   The \textbf{data2 max} field is the maximum value of the event
   for the filter to match.

\subsubsection{Seq24rc / MIDI Control Pattern Group}
\label{subsubsec:seq24_rc_file_midi_control_pattern_group}

   Complex?  Here is an example for the some of the first 32 lines, which
   comprise the \textsl{pattern group}.
   The following is an example of responding
   to Note On events for note 0, with any velocity, to turn the pattern on,
   and Note off events for note 0, and any velocity, to turn the pattern
   off.

   \begin{verbatim}
	          Toggle                 On                      Off
        1 [0 0 0 0 0 0]      [1 0  144 0 0 127]       [1 0 128 0 0 127]
   \end{verbatim}

   The \textbf{Toggle} field is off (inactive).  All values are 0.
   There is no way to use MIDI control to toggle sequence 1.

   The \textbf{On} value is on (1 = active).
   The \textbf{nverse} value is off (0 = inactive).
   The \textbf{MIDI status byte}, 144, which is 0x90 (hex), which is a Note On
   event on channel 0.  However, the channel is ignored.
   The \textbf{data1} values sets the actual Note value to 0, meaning the
   lowest possible MIDI note (pitch) value.
   \textbf{data2 min} value sets
   the minimum value to 0, and
   \textbf{data2 max} sets the maximum value to 127.
   Thus, receiving any Note On velocity for note 0 will turn sequence 1
   \textsl{on}.

   The \textbf{Off} field is on (active), and it is set up the same way as the
   \textbf{On} field, except that the status message is
   128, which is 0x80 (hex), which is a Note Off event on channel 0.
   Thus, receiving any Note Off velocity for note 0 will turn sequence 1
   \textsl{off}.

   So, basically, pattern 1 starts when any Note On for MIDI note 0
   is received, and it stops when any Note Off for MIDI note 0 is received.  
   One can easily extend this so that Note On/Off values from 0 to 31
   control the corresponding pattern slot.

   The following example would map a row of sequences to one knob sending
   out changes for Control Code 1:

   \begin{verbatim}
	          Toggle                 On                      Off
        0 [0 0 0 0 0 0]      [1 1 176 1   0   15]     [0 0 0 0 0 0]
        1 [0 0 0 0 0 0]      [1 1 176 1  16   31]     [0 0 0 0 0 0]
        2 [0 0 0 0 0 0]      [1 1 176 1  32   47]     [0 0 0 0 0 0]
        3 [0 0 0 0 0 0]      [1 1 176 1  48   63]     [0 0 0 0 0 0]
        4 [0 0 0 0 0 0]      [1 1 176 1  64   79]     [0 0 0 0 0 0]
        5 [0 0 0 0 0 0]      [1 1 176 1  80   95]     [0 0 0 0 0 0]
        6 [0 0 0 0 0 0]      [1 1 176 1  96  111]     [0 0 0 0 0 0]
        7 [0 0 0 0 0 0]      [1 1 176 1 112  127]     [0 0 0 0 0 0]
   \end{verbatim}

   The \textbf{on} field is on (active).  Inverse is active.  The
   \textbf{MIDI status byte}, 176, is 0xB0 (hex), which is a Control Change
   event (channel ignored).  \textbf{data1} is 1, which is the controller
   number for a Modulation Wheel.  The \textbf{data2} ranges are set so
   that, as the controller data increases (as the modulation-wheel knob is
   turned, so to speak), patterns 0 through 7 come on one at a time until
   all are running.

   Here is another example:
   The \textsl{Akai MPK Mini} has a Sustain button and we can set the
   Sustain MIDI event (with MIDI status byte 176 [0xB0] to represent a
   Controller event, and control/mode change number 64 [0x40] to
   represent the Sustain or Pedal control) up as the queue modifier in
   the \texttt{mod queue} entry:

   \begin{verbatim}
      # mod queue
      70 [0 0   0   0   0   0] [1 0 176  64 127 127] [1 0 176  64   0   0]
   \end{verbatim}

   So when the Sustain button is held down, and one presses one of the pads
   on the \textsl{MPK Mini}, the corresponding sequence gets queued.
   (STILL NOT CLEAR WHY).

   Here's a little table of the decimal numbers for some commonly-used MIDI
   controls:

   \begin{verbatim}
      128 Note On event 
      129 Note Off event 
      160 Polyphonic aftertouch event
      176 Controller event 
      192 Program change 
      208 Aftertouch 
      224 Pitch wheel 
   \end{verbatim}

\subsubsection{Seq24rc / MIDI Control Mute In Group}
\label{subsubsec:seq24_rc_file_midi_control_mute_in_group}

   \index{mute-in group}
   \index{[midi-control]!mute-in group}
   This section controls 32 groups of mutes in the same way as 
	defined for \texttt{[midi-control]}, and is in fact placed in the
   \texttt{[midi-control]} section.

   A group is a set of patterns that can toggle their playing state
   together.  Every group contains all 32 sequences in the active screen set
   (see after).

   So, this part of the MIDI Control section is used for muting and unmuting
   (and toggling) a group of patterns.

\subsubsection{Seq24rc MIDI Control Automation Group}
\label{subsubsec:seq24_rc_file_midi_control_automation_group}

   \index{automation group}
   \index{[midi-control]!automation group}

   \setcounter{ItemCounter}{0}      % Reset the ItemCounter for this list.

   \itempar{bpm up}{[midi-control]!bpm up}
   Increases the BPM (speed) of the sequencer based on MIDI input.

   \itempar{bpm down}{[midi-control]!bpm down}
   Decreases the BPM (speed) of the sequencer based on MIDI input.

   \itempar{screen-set up}{[midi-control]!screen-set up}
   Increases the active screen-set of the sequencer based on MIDI input.

   \itempar{screen-set down}{[midi-control]!screen-set down}
   Decreases the active screen-set of the sequencer based on MIDI input.

   \itempar{mod replace}{[midi-control]!mod replace}
   This item provides a way to automate replacement.
   TODO.
   \index{todo!explain replacement}
   Explain the concept of replacement.

   \itempar{mod snapshot}{[midi-control]!mod snapshot}
   This item provides a way to automate snapshots.
   TODO.
   \index{todo!explain snapshots}
   Explain the concept of snapshots.

   \itempar{mod queue}{[midi-control]!mod queue}
   This item provides a way to automate queueing.
   TODO.
   \index{todo!explain queue}
   Explain the concept of queue.

   \itempar{mod gmute}{[midi-control]!mod gmute}
   \index{group!muting}
   This item provides a way to automate group-muting.
   Explain the concept of snapshots.

   \itempar{mod glearn}{[midi-control]!mod glearn}
   \index{group!learning}
   This item provides a way to automate group-learning.
   TODO.
   \index{todo!group learning}
   Explain the concept of group-learning.

   \itempar{screen-set play}{[midi-control]!screen-set play}
   This item provides a way to automate screen set play.
   TODO.
   \index{todo!explain queue}
   Explain the concept of screen set play.

\subsection{Seq24rc / Mute-Group Section}
\label{subsec:seq24_rc_file_mute_group}
     
   This section is delimited by the \texttt{[mute-group]} construct.

   \begin{verbatim}
      [mute-group]
      1024
       0 [0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0]
       1 [0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0]
       2 [0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0]
      ...      ...               ...               ...               ...
      31 [0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0]
   \end{verbatim}

   The initial number, 1024 is...... WHAT?

   In this group are the definitions of the state of the 32 sequences
   in the playing screen set when a group is selected.
   group [state of the first 8 sequences] [second 8] [third 8] [fourth 8]

   After the list of sequences and their MIDI events, one can 
   set \textsl{Seq24} to handle MIDI events and change some more settings
   in \texttt{.seq24rc}.

\subsection{Seq24rc / MIDI-Clock Section}
\label{subsec:seq24_rc_file_midi_clock}

   \index{[midi-clock]}
   The MIDI Clock fields will contain the clocking state from the last 
   time \textsl{Seq24} was run.  Turn off the clock with a 0, or on with a 1.
   This section has 16 entries, one for each MIDI output buss that
   \textsl{Seq24} supports.

   This configuration item is the same as the 
   \textbf{MIDI Clock} tab described in
   \paragraphref{paragraph:seq24_menu_file_options_midi_clock}
   
   Here is the format:

   \begin{verbatim}
      [midi-clock]
      16
       0 0  #  [1] seq24 1
       1 0  #  [2] seq24 2
       2 0  #  [3] seq24 3
       3 0  #  [4] seq24 4
       4 0  #  [5] seq24 5
       5 0  #  [6] seq24 6
       6 0  #  [7] seq24 7
       7 0  #  [8] seq24 8
       8 0  #  [9] seq24 9
       9 0  # [10] seq24 10
      10 0  # [11] seq24 11
      11 0  # [12] seq24 12
      12 0  # [13] seq24 13
      13 0  # [14] seq24 14
      14 0  # [15] seq24 15
      15 0  # [16] seq24 16
   \end{verbatim}

\subsection{Seq24rc / Keyboard Control Section}
\label{subsec:seq24_rc_file_keyboard_control}
        
   \index{[keyboard control]}
   The keyboard control is a dump of the keys that \textsl{Seq24}
   recognises, and each key's corresponding sequence number.
   Note that the first number corresponds to the number of sequences in
   the active screen set.

   \begin{verbatim}
      [keyboard-control]
      32
      # Key #, Sequence # 
      44  31        # comma
      49  0         # 1
      50  4         # 2
      51  8         # 3
      52  12        # 4
      53  16        # 5
      54  20        # 6
      55  24        # 7
      56  28        # 8
      97  2         # a
      98  19        # b
      99  11        # c
      100  10       # d
      101  9        # e
      102  14       # f
      103  18       # g
      104  22       # h
      105  29       # i
      106  26       # j
      107  30       # k
      109  27       # m
      110  23       # n
      113  1        # q
      114  13       # r
      115  6        # s
      116  17       # t
      117  25       # u
      118  15       # v
      119  5        # w
      120  7        # x
      121  21       # y
      122  3        # z
   \end{verbatim}

\subsection{Seq24rc / Keyboard Group Section}
\label{subsec:seq24_rc_file_keyboard_group}

   \index{[keyboard-group]}
   This section is the same as
   \textbf{[keyboard-control]}, but to control groups.
   The keyboard group specifies more automation for the application.  The
   first number specifies the Key number, and the second number specifies
   the Group number.

   Additional control:

   \begin{enumber}
   	\item \textbf{\# bpm up and down}.
	      Keys to control BPM (beats per minute).
      \item \textbf{\# screen set up and down}.
	      Keys for changing the active screenset.
      \item \textbf{\# group functionality on, off, learn}.
         \index{group learn}
	      Note that the group learn key is a modifier key to be held while 
         \index{group toggle}
         pressing a group toggle key.
      \item \textbf{\#replace, queue, snapshot\_1, snapshot\_2, keep queue}.
         These are the other modifier keys explained in section 3a.
   \end{enumber}

	To see the required key codes when pressed, run \texttt{seq24} with
   the \texttt{--show\_keys}.

   Some keys should not be assigned to control sequences in \textsl{Seq24} as
   they are already assigned in the \textsl{Seq24} menu (with \texttt{Ctrl}). 

   This configuration item is the same as the 
   \textbf{Keyboard} tab described in
   \sectionref{paragraph:seq24_menu_file_options_keyboard}.

   \begin{verbatim}
      [keyboard-group]
      # Key #, group # 
      32
      33  0         # exclam
      34  1         # quotedbl
      35  2         # numbersign
      36  3         # dollar
      37  4         # percent
      38  5         # ampersand
      40  7         # parenleft
      47  6         # slash
      59  31        # semicolon
      65  16        # A
      66  28        # B
      67  26        # C
      68  18        # D
      69  10        # E
      70  19        # F
      71  20        # G
      72  21        # H
      73  15        # I
      74  22        # J
      75  23        # K
      77  30        # M
      78  29        # N
      81  8         # Q
      82  11        # R
      83  17        # S
      84  12        # T
      85  14        # U
      86  27        # V
      87  9         # W
      88  25        # X
      89  13        # Y
      90  24        # Z
      39 59         # bpm up, down: apostrophe semicolon
      93 91 65360   # screen set up, down, play: bracketright bracketleft Home
      236 39 65379  # group on, off, learn: igrave apostrophe Insert
      # replace, queue, snapshot_1, snapshot 2, keep queue:
      65507 65508 65513 65514 92  # Control_L Control_R Alt_L Alt_R backslash
      1             # show_ui_sequence_key (1=true/0=false)
      32            # space start sequencer
      65307         # Escape stop sequencer
   \end{verbatim}

\subsection{Seq24rc / JACK Transport}
\label{subsec:seq24_rc_file_jack_transport}

   \index{[jack-transport]}
   The JACK Transport options are also command-line options, as indicated in
   the comments below.

   This configuration item is the same as the 
   \textbf{Jack Sync} tab described in
   \sectionref{paragraph:seq24_menu_file_options_jack_sync}.

   \index{--jack\_transport}
   \index{--jack\_master}
   \index{--jack\_master\_cond}
   \index{--jack\_start\_mode}
   \begin{verbatim}
      [jack-transport]

      # --jack_transport: Enable sync with JACK Transport.  Seq24 will sync
      # to JACK transport if the JACK server is available.
      0

      # --jack_master: Seq24 will attempt to serve as JACK Master.
      0

      # --jack_master_cond: Seq24 will fail to be JACK master if there is
      # already a JACK master set.
      0

      # --jack_start_mode n
      # 0 = Playback will be in live mode.  Use this value to allow muting
      #     and unmuting of loops.
      # 1 = Playback will be in performance mode.  Playback will use the song
      #     editor's data.  When Seq24 is synced to JACK, the playback command
      #     comes from the JACK server.  Seq24 is in performance mode by default.
      1
   \end{verbatim}

\subsection{Seq24rc / Other Sections}
\label{subsec:seq24_rc_file_other_midi}

   \index{[midi-clock-mod-ticks]}
   This configuration item is the same as the
   \textbf{Clock Start Modulo} option described in
   \paragraphref{paragraph:seq24_menu_file_options_midi_clock}.

   \begin{verbatim}
      [midi-clock-mod-ticks]
      64
   \end{verbatim}

   \index{[midi-input]}
   This configuration item is the same as the 
   \textbf{MIDI Input} tab described in
   \paragraphref{paragraph:seq24_menu_file_options_midi_input}.
   The "1" is undoubtedly a record count, and would equal the number of
   supported input ports.
   This "rc" entry here has two variables; the first is the record number or
   port number, and the second number indicates whether it is disabled (0),
   or enabled (1).

   \begin{verbatim}
      [midi-input]
      1
      0 0            # [0] seq24 0
   \end{verbatim}

   There is no user-interface item for the following value, but
   it does correspond to the \texttt{--manual\_alsa\_ports} command-line
   option.

   \index{[manual-alsa-ports]}
   \begin{verbatim}
      # set to 1 if you want seq24 to create its own alsa ports and
      # not connect to other clients

      [manual-alsa-ports]
      1
   \end{verbatim}

   \index{jack!manual-alsa-ports}
   Turning on the manual-alsa-ports option is necessary if one
   wants to use \textsl{Seq24} with JACK.
   It will create ports as per the settings in the "user" configuration file's
   \texttt{user-midi-bus-definitions} and \texttt{user-midi-bus-N} sections.
   These definitions can be used by JACK for connection, and these definitions
   can be used to specifically rename the ports that exist in the system.
   However, this option is misleading if one wants to have access to the
   actual ALSA ports that exist on the system.
   The next option gets around that issue.
   \index{[interaction-method]}
   This configuration item is the same as the 
   \textbf{Mouse} tab described in
   \paragraphref{paragraph:seq24_menu_file_options_mouse}.

   \index{[interaction-method]}
   \begin{verbatim}
      # 0 - 'seq24' (original seq24 method)
      # 1 - 'fruity' (similar to a certain fruity sequencer we like)

      [interaction-method]
      0
   \end{verbatim}


   The following item refers to the last directory in which one opened or
   saved a MIDI file.

   \index{[last-used-dir]}
   \begin{verbatim}
      [last-used-dir]

      # Last used directory.
   \end{verbatim}

%-------------------------------------------------------------------------------
% vim: ts=3 sw=3 et ft=tex
%-------------------------------------------------------------------------------
